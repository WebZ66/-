# 网络模型

目前主要使用的是OSI七层网络模型

- 应用层
- 表示层
- 会话层
- 运输层：会应用层之间的通信提供数据传输服务
- 网络层
- 数据链路层
- 物理层





# 传输层

## UDP

`用户数据报协议`

**特点：**

- UDP是无连接的，无需像TCP一样建立点对点的连接，采用广播的方式，所以可以一对多
- 面向报文的，对于上层交付的报文，UDP既不拆分也不合并，直接交付给下一层
- UDP不保证可靠性，但是传输效率很高，所以常用于视频电话等。



## TCP

`传输控制协议`

**特点：**

- TCP是面向连接的，使用TCP前必须先建立 `点对点的连接`，因此TCP支持点对点的 `全双工通信，双方都可以接收和发送报文`。建立连接是三次握手，断开连接是四次挥手
- TCP是面向字节流的，TCP报文中以字节流的方式进行传输
- TCP传输是可靠的，通过`确认号`和`超时重传机制`保证TCP的可靠传输



### TCP的可靠传输

TCP基于确认号和超时重传机制实现可靠传输。发送方发送报文，接受方接受到后，需要发送ACK=1，ack=序列号+1,作为确认报文。如果发送方没有接收到这个确认报文，那么超过一定时间就会重发之前的报文



### TCP的拥塞控制

- 慢开始：以指数级增长，达到门限值后，就执行拥塞避免
- 拥塞避免
- 快重传
- 快恢复：`收到连续三个重复的确认，执行快重传`



### TCP的流量控制

TCP的流量控制其实就是基于可变大小的滑动窗口，只发送滑动窗口内部的字节，使得发送方发送的不要过快，让接收方来得及接收



### TCP的粘包

TCP为什么会有粘包呢？

这是因为TCP是面向字节流的，它的报文传输过程中是以字节流的方式进行传输的。比如说a的数据比较少，那么发送了a的全部数据时，还发送了部分b的数据，这就是粘包。

解决措施：采用边界处理，在包与包的字节流之间添加边界字符。



### 三次握手

![image-20231224121229180](https://gitee.com/zhengdashun/pic_bed/raw/master/img/image-20231224121229180.png) 

**三次握手过程：**

1. 客户端发送请求连接报文，在请求连接报文中有标志位SYN=1，序列号seq=x
2. 服务端接收到后，同意建立连接，发送确认报文，标志位SYN=1，ACK=1,ack=x+1,seq=y
3. 因为TCP是全双工通信，因此客户端也需要接收服务端数据。客户端需要发送一个确认报文，ACK=1，seq=x+1,ack=y+1

至此TCP建立成功



#### 为什么需要三次握手，不能两次

因为TCP是全双工的双向通信，前两次握手只能确认客户端发送报文正常，并不能确定客户端接收报文正常，因此需要三次握手来确认双方的收发能力都正常



#### 三次握手中最容易攻击的是哪一次

第二次。即客户端伪造出大量的请求报文，服务端需要保存这些连接报文确认和哪个客户端进行连接，这会导致服务端压力过大，从而导致崩溃。





### 四次挥手

![ ](https://gitee.com/zhengdashun/pic_bed/raw/master/img/image-20231224121742412.png)

1. 客户端发送断开连接报文  标志位FIN=1，seq=x
2. 服务端还有未发送完的内容，继续发送  ACK=1 ，seq=y，ack=x+1
3. 服务端发送完毕后，同意断开连接，发送报文 FIN=1 ACK=1 seq=m，ack=x+1
4. 客户端收到服务端的确认报文后，确认断开连接，发送ACK=1，seq=x+1，ack=m+1，服务端也就知道客户端断开了连接



#### 四次挥手为什么要等待2msl

- 为了保证客户端最后一个确认报文能够达到服务端，让服务端知道客户端已经断开连接了，从而服务端也就断开连接。

- 为了防止失效的报文段影响到下一次TCP连接





# 应用层



## HTTP

**定义：HTTP全称是超文本传输协议，端口号80，是一种`基于TCP的应用层全双工通信协议`，是客户端和服务器请求和响应的标准**

**特点：**

- 无状态的，**http请求是无状态的**，**服务端不会保存客户端的状态信息**，每个http请求都是独立的。
- http传输是明文传输，所以不安全，但也因此http传输速率很快



### HTTP请求方法

- get：get请求的参数需要携带在url中，因为浏览器对url的长度有限制，因此就会导致了对get请求参数的限制，只能小于2083个字符
- post：请求参数放在请求体中
- delete
- put
- head：head和get请求类似，但是只返回请求头没有请求体
- options：常用于**cors非简单请求中的预检请求**，询问服务器所支持的请求方法
- trace：`回显`服务端所接收到的请求
- connect：`请求与代理服务器之间建立通信`。



### 常见的http请求头字段

Host：指定被请求的主机名和端口号。因为随着虚拟主机的出现，一台物理主机上可能出现多个虚拟主机，需要通过host确认被请求的主机名和端口号。

connection：keep-alive。用来建立持久性连接

refer：表明该请求来自于哪一个源(即协议+域名+端口号)





### HTTP1.0 1.1 2.0的区别

HTTP1.0是最基础的版本，请求方法只有get和post，且是非持久性连接。每次进行http请求时，都需要建立tcp连接，请求完成后，需要断开tcp连接。



HTTP1.1：①通过connection:keep-alive字段实现持久性连接，使得`多个http请求可以共用同一个tcp连接`，无需断开。

②添加了缓存策略，在响应头中添加了cache-control字段，实现了客户端缓存功能

③实现了断点续传，客户端发送请求后，服务端可以只响应部分数据，返回状态码206，等到所有资源返回后，再返回状态码200

④新增了请求方法put delete等等



HTTP2.0：①http2.0是一个二进制协议，无论是头部还是数据部分都是二进制流，统称为帧。这是http2.0实现多路复用的关键，从而支持多个http请求并行的请求和响应。解决了http的对头堵塞问题。因为http请求是一发一收，如果前一个请求耗时过长，就会导致后面请求的堵塞。

②http2.0引入了头部信息压缩机制，通过Hpack算法压缩头信息，在客户端和服务端之间建立头信息压缩表，所有头信息都压缩后存入其中，使用头信息就直接使用索引。





## HTTPS

**定义：HTTPS超文本传输安全协议，端口号443，在HTTP基础上加了一层SSL/TLS来实现加密数据。它使用了对称加密和非对称加密两种方式**

